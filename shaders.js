var crowd_fragment_shader_src = [
'#version 300 es',
'precision mediump float;',
'//in vec2 uv_color;',
'out vec4 fragColor;',
'/*',
'void main() ',
'{',
'    fragColor = vec4(uv_color[0], uv_color[1], 0.0, 1.0);',
'}',
'*/',
'',
'/*',
'uniform vec2 resolution;',
'void main() ',
'{',
'    // Normalized pixel coordinates (from 0 to 1)',
'    //vec2 uv = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;',
'    // Output to screen',
'    //gl_FragColor = vec4(uv, 0.0, 1.0);',
'}',
'*/',
'// resources: https://github.com/nicoptere/raymarching-for-THREE',
'uniform vec2 resolution;',
'uniform float time;',
'uniform float fov;',
'uniform float raymarchMaximumDistance;',
'uniform float raymarchPrecision;',
'uniform vec3 camera;',
'uniform vec3 target;',
'//uniform samplerCube cubemap;',
'uniform vec3 anchors[15];',
'',
'//uses most of the StackGL methods',
'//https://github.com/stackgl',
'//https://github.com/hughsk/glsl-square-frame',
'vec2 squareFrame(vec2 screenSize) {',
'  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;',
'  position.x *= screenSize.x / screenSize.y;',
'  return position;',
'}',
'vec2 squareFrame(vec2 screenSize, vec2 coord) {',
'  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;',
'  position.x *= screenSize.x / screenSize.y;',
'  return position;',
'}',
'//https://github.com/stackgl/glsl-look-at/blob/gh-pages/index.glsl',
'mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {',
'  vec3 rr = vec3(sin(roll), cos(roll), 0.0);',
'  vec3 ww = normalize(target - origin);',
'  vec3 uu = normalize(cross(ww, rr));',
'  vec3 vv = normalize(cross(uu, ww));',
'  return mat3(uu, vv, ww);',
'}',
'//https://github.com/stackgl/glsl-camera-ray',
'vec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {',
'  return normalize(camMat * vec3(screenPos, lensLength));',
'}',
'vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {',
'  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);',
'  return getRay(camMat, screenPos, lensLength);',
'}',
'/////////////////////////////////////////////////////////////////////////',
'mat3 rotationMatrix3(vec3 axis, float angle)',
'{',
'    axis = normalize(axis);',
'    float s = sin(angle);',
'    float c = cos(angle);',
'    float oc = 1.0 - c;',
'    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,',
'                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,',
'                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );',
'}',
'/////////////////////////////////////////////////////////////////////////',
'//primitives',
'vec2 sphere( vec3 p, float radius, vec3 pos , vec4 quat)',
'{',
'    mat3 transform = rotationMatrix3( quat.xyz, quat.w );',
'    float d = length( ( p * transform )-pos ) - radius;',
'    return vec2(d,0.);',
'}',
'vec2 sphere( vec3 p, float radius, vec3 pos )',
'{',
'    float d = length( p -pos ) - radius;',
'    return vec2(d,0.);',
'}',
'vec2 roundBox(vec3 p, vec3 size, float corner, vec3 pos, vec4 quat )',
'{',
'    mat3 transform = rotationMatrix3( quat.xyz, quat.w );',
'    return vec2( length( max( abs( ( p-pos ) * transform )-size, 0.0 ) )-corner,1.);',
'}',
'vec2 line( vec3 p, vec3 a, vec3 b, float r )',
'{',
'    vec3 pa = p - a, ba = b - a;',
'    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );',
'    return vec2( length( pa - ba*h ) - r, 1. );',
'}',
'vec2 sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )',
'{',
'    vec2 q = vec2( length(p.xz), p.y );',
'    ',
'    vec2 k1 = vec2(r2,h);',
'    vec2 k2 = vec2(r2-r1,2.0*h);',
'    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);',
'    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );',
'    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;',
'    return vec2( s*sqrt( min(dot(ca, ca),dot(cb,cb)) ), 1.0);',
'}',
'//operations',
'vec2 unionAB(vec2 a, vec2 b){return vec2(min(a.x, b.x),1.);}',
'vec2 intersectionAB(vec2 a, vec2 b){return vec2(max(a.x, b.x),1.);}',
'vec2 blendAB( vec2 a, vec2 b, float t ){ return vec2(mix(a.x, b.x, t ),1.);}',
'vec2 subtract(vec2 a, vec2 b){ return vec2(max(-a.x, b.x),1.); }',
'//http://iquilezles.org/www/articles/smin/smin.htm',
'vec2 smin( vec2 a, vec2 b, float k ) { float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), 1. ); }',
'float smin( float a, float b, float k ) { float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 ); return mix( b, a, h ) - k*h*(1.0-h); }',
'//http://www.pouet.net/topic.php?post=367360',
'const vec3 pa = vec3(1., 57., 21.);',
'const vec4 pb = vec4(0., 57., 21., 78.);',
'float perlin(vec3 p) ',
'{',
'    vec3 i = floor(p);',
'    vec4 a = dot( i, pa ) + pb;',
'    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;',
'    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);',
'    a.xy = mix(a.xz, a.yw, f.y);',
'    return mix(a.x, a.y, f.z);',
'}',
'float zigzag( float x, float m )',
'{',
'    return abs( mod( x, (2.*m) ) -m);',
'}',
'/////////////////////////////////////////////////////////////////////////',
'/////////////////////////////////////////////////////////////////////////',
'const int raymarchSteps = 50;',
'const float PI = 3.14159;',
'//no height',
'vec2 plane( vec3 p , vec3 n) { return vec2( dot(p, n), 1. ); }',
'//with height',
'vec2 plane( vec3 p , vec4 n) { return vec2( dot(p, n.xyz) + n.w, 1. ); }',
'vec2 field( vec3 position )',
'{',
'    //position',
'    vec3 zero = vec3(0.);',
'    //rotation',
'    vec4 quat = vec4( 1.0, 0.0, 0.0, 0.5 );',
'    float rad = 500.;',
'    vec3 dir = vec3(.0,.0, time * 4.);',
'    //vec2 ground = sphere( position + perlin( ( position + dir ) * .1 ), rad, vec3( 0.,-rad + 2.,0. ) );',
'    //ground = unionAB( ground, plane( position - vec3( 0.,100.,0. ), vec3( 0.,-1.,0. ) ) );',
'    float o = zigzag( position.x, .25 ) + zigzag( position.x, .21 );',
'    float radius = .5;',
'    float blendFactor = 0.4;',
'    dir = vec3( 0., -time * 3., 0. );',
'    float s = fract( sin( sin( floor( position.x / 0.01 ) * 2. ) / 0.01 ) * 10. ) * 0.;',
'    // head',
'    //vec2 skeleton = line( position, anchors[0] + vec3(0.,1.,0.), anchors[1], .5 );',
'    vec2 skeleton = sphere( position, radius * 2.2, (anchors[0] + anchors[1]) / 2.0 + vec3(0.,1.,0.));',
'    //blend distance (color blend)',
'    float dis0 = skeleton.x;',
'    //left arm',
'    skeleton = smin( skeleton, line( position, anchors[1], anchors[2], radius ), blendFactor ); //shoulder L',
'    skeleton = smin( skeleton, line( position, anchors[2], anchors[3], radius ), blendFactor );',
'    skeleton = smin( skeleton, line( position, anchors[3], anchors[4], radius ), blendFactor );',
'    //right arm',
'    skeleton = smin( skeleton, line( position, anchors[1], anchors[5], radius ), blendFactor ); //shoulder R',
'    skeleton = smin( skeleton, line( position, anchors[5], anchors[6], radius ), blendFactor );',
'    skeleton = smin( skeleton, line( position, anchors[6], anchors[7], radius ), blendFactor );',
'    //spine',
'    skeleton = smin( skeleton, line( position, anchors[1], anchors[8], radius * 2.5 ), blendFactor );',
'    //belly',
'    skeleton = smin( skeleton, sphere( position, radius * 3.5, anchors[8] ), blendFactor );',
'    //left leg',
'    skeleton = smin( skeleton, line( position, anchors[9], anchors[10], radius ), blendFactor );',
'    skeleton = smin( skeleton, line( position, anchors[10], anchors[11], radius ), blendFactor );',
'    //right leg',
'    skeleton = smin( skeleton, line( position, anchors[12], anchors[13], radius ), blendFactor );',
'    skeleton = smin( skeleton, line( position, anchors[13], anchors[14], radius ), blendFactor * 1.5 );',
'    vec2 _out = skeleton;',
'    _out.y = smoothstep( 0., dis0, _out.x );',
'    return _out;',
'}',
'/////////////////////////////////////////////////////////////////////////',
'// the methods below this need the field function',
'/////////////////////////////////////////////////////////////////////////',
'//the actual raymarching from:',
'//https://github.com/stackgl/glsl-raytrace/blob/master/index.glsl',
'vec2 raymarching( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {',
'    float latest = precis * 2.0;',
'    float dist   = 0.0;',
'    float type   = -1.0;',
'    for (int i = 0; i < raymarchSteps; i++) {',
'        if (latest < precis || dist > maxd) break;',
'        vec2 result = field( rayOrigin + rayDir * dist );',
'        latest = result.x;',
'        dist  += latest;',
'        type = result.y;',
'    }',
'    vec2 res    = vec2(-1.0, -1.0 );',
'    if (dist < maxd) { res = vec2( dist, type ); }',
'    return res;',
'}',
'//https://github.com/stackgl/glsl-sdf-normal',
'vec3 calcNormal(vec3 pos, float eps) ',
'{',
'  const vec3 v1 = vec3( 1.0,-1.0,-1.0);',
'  const vec3 v2 = vec3(-1.0,-1.0, 1.0);',
'  const vec3 v3 = vec3(-1.0, 1.0,-1.0);',
'  const vec3 v4 = vec3( 1.0, 1.0, 1.0);',
'  return normalize( v1 * field( pos + v1*eps ).x +',
'                    v2 * field( pos + v2*eps ).x +',
'                    v3 * field( pos + v3*eps ).x +',
'                    v4 * field( pos + v4*eps ).x );',
'}',
'vec3 calcNormal(vec3 pos) {',
'  return calcNormal(pos, 0.002);',
'}',
'vec3 rimlight( vec3 pos, vec3 nor )',
'{',
'    vec3 v = normalize(-pos);',
'    float vdn = 1.0 - max(dot(v, nor), 0.0);',
'    return vec3(smoothstep(0., 1.0, vdn));',
'}',
'void main() ',
'{',
'    vec2 screenPos = squareFrame( resolution );',
'    vec3 rayDirection = getRay( camera, target, screenPos, fov );',
'    vec2 collision = raymarching( camera, rayDirection, raymarchMaximumDistance, raymarchPrecision );',
'    vec3 col = vec3( 0.85 );',
'    // background color',
'    //gl_FragColor = vec4(mix( col, vec3(1.), screenPos.y), 1. );',
'    fragColor = vec4(0.3, 0.3, 0.34, 1. );',
'    ',
'    if ( collision.x > -0.5)',
'    {',
'        vec3 pos = camera + rayDirection * collision.x;',
'        vec3 nor = calcNormal( pos,.1 );',
'        //vec3 tex = textureCube( cubemap, nor ).rgb;',
'        //col = mix( col, tex, collision.y );',
'        col = col * rimlight( pos, nor ) + nor * .2;',
'        fragColor = vec4( col, 1. );',
'    }',
'}',
].join("\n");
var crowd_vertex_shader_src = [
'#version 300 es',
'in vec4 v_position;',
'//uniform mat4 u_viewProj;',
'//out vec2 uv_color;',
'void main() ',
'{',
'  gl_Position = v_position;',
'  //uv_color = vec2(v_position[0], v_position[1]);',
'}     ',
].join("\n");
var tex_fragment_shader_src = [
'precision highp float;',
'uniform sampler2D u_image0; ',
'uniform sampler2D u_image1;',
'uniform sampler2D u_comfortMap; ',
'uniform bool u_useComfortMap;',
'uniform vec2 windowSize;',
'uniform float numAgents;',
'varying vec2 fs_uv;',
'const int R = 1337;',
'const int RES = 10;',
'int toID(vec4 col) {',
'  return int(col.r*float(RES)+0.5) + int(col.g*float(RES)+0.5)*RES + int(col.b*float(RES)+0.5)*RES*RES;',
'}',
'void main(void) {',
'  vec4 col = texture2D(u_image0, fs_uv);',
'  int id = toID(col);',
'  vec4 data = texture2D(u_image1, vec2(float(id)/(numAgents-0.5), 0.0));',
'  vec3 pos = vec3(data.xy, 0);',
'  vec3 gol = vec3(data.zw, 0);',
'  vec3 golVec = gol - pos;',
'  vec3 marker = 2.0*vec3(fs_uv, 0) - vec3(1,1,0);',
'  vec3 markerVec = vec3(fs_uv, 0) - pos;',
'  float weight = 1.0 + dot(normalize(markerVec), normalize(golVec));',
'  weight *= (',
'    (1.0 - float(u_useComfortMap)) + ',
'    float(u_useComfortMap)*texture2D(u_comfortMap, fs_uv).x',
'  );',
'  bool mask = length(markerVec) < float(R) / windowSize.x;',
'  weight = float(mask) * weight;',
'  gl_FragColor = vec4(weight,weight,weight,1);',
'}',
].join("\n");
var tex_vertex_shader_src = [
'attribute vec4 vs_pos;',
'attribute vec2 vs_uv;',
'varying vec2 fs_uv;',
'void main(void) ',
'{',
'  gl_Position = vs_pos;',
'  fs_uv = vs_uv;',
'}',
].join("\n");
